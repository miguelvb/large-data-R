{
    "contents" : "\n#' Redirecting a moved ffdf \n#' \n#'  redirffdf (ff, newdir) , allows to move \"manually\" a ffdf folder, saved with save.ffdf, \n#'  and avoid file access error, making a redir(ffdf, newdir), with newdir, the dir \n#'  (without counting the ffdf name dir) where we moved the ffdf. \n#'  \n#'  @param ff An ffdf data base \n#'  @param newdir A new directory where the ffdf was moved **manually**\n#'  @return A ffdf, with \"corrected\" file-path \n#'  @export\n\nredirffdf <- function(ff, newdir = getwd()) {\n  require(ffbase)\n  nn <- substitute(ff)\n  nn <- all.names(nn)\n  #print(nn)\n  for (x in physical(ff)) {\n    fn <- basename(filename(x))\n    physical(x)$filename <- file.path(newdir,nn, fn)\n  }\n  return (ff)\n}\n\n\n#' Redirecting a moved ffdf \n#' \n#'  redirffdfffdfsave (ff, newdir) , allows to move \"manually\" a ffdf folder, saved with **ffdfsave**, \n#'  and avoid file access error, making a redirffdfffdfsave(ffdf, newdir), with newdir, the dir \n#'  (without counting the ffdf name dir) where we moved the ffdf. \n#'  \n#'  @param ff An ffdf data base \n#'  @param newdir A new directory where the ffdf was moved **manually**\n#'  @return A ffdf, with \"corrected\" file-path \n#'  @export\n\nredirffdfffdfsave <- function(ff, newdir = getwd()) {\n  require(ffbase)\n  nn <- substitute(ff)\n  nn <- all.names(nn)\n  nn <- paste(nn,\"ff\", sep= \"\")\n  for (x in physical(ff)) {\n    fn <- basename(filename(x))\n    physical(x)$filename <- file.path(newdir,nn, fn)\n  }\n  return (ff)\n}\n\n\n#' Find if a ffdf column is as 1:N (ordered \"row numbers\")\n#' \n#' Will check if data is ordered by column colname\n#' i.e. if colname is exactly as 1,2,3,4,5,.... ,nrows. \n#' @export\n#' @param data An ffdf. \n#' @param colname = the name of the column to check. \n\nisorderedbyrowcol <- function(data,colname){\n  require(ffbase)\n  rows <- ff(1:nrow(data)); \n  ord <- rows - data[[colname]]; \n  lo <- ffwhich(ord, ord !=0); \n  return(length(lo) == 0)\n  \n}\n\n\n\n#'  Quote a \"list\" of names : \n#'  \n#' quotenames(ident,treatment,diagnose) will give a character vector = c(\"ident\",\"treatment\",\"diagnose\")\n#' \n#' very useful to quote a large list of names that are not quoted (param names, var names, etc)\n#' @export\n\nquotenames <- function(...){\n  x <- substitute(c(...))\n  x <- all.names(x)\n  N <- length(x)\n  x <- x[2:N]\n  x\n  \n}\n\n#'  Quote a \"list\" of names : \n#'  \n#' same as \"quotenames(x)\"\n#' @export\n\nqn <- function(...){\n  x <- substitute(c(...))\n  x <- all.names(x)\n  N <- length(x)\n  x <- x[2:N]\n  x\n  \n}\n\n\n#' Substitute danish letters  \n#' \n#' Will substitute danish letters by english ones. \n#' @export \nchangedanishletters <- function(y){\n  \n  x <- gsub(\"æ\",\"a\",y)\n  x <- gsub(\"Æ\",\"A\",x)\n  x <- gsub(\"ø\",\"o\",x)\n  x <- gsub(\"Ø\",\"O\",x)\n  x <- gsub(\"å\",\"a\",x)\n  x <- gsub(\"Å\",\"A\",x)\n  x  \n}\n\n\n#' Order a ffdf, in splits to avoid memory problems. \n#' \n#' orderffdf will order the ffdf using a column \n#' it will make the process using each time a portion of the total database \n#' @param data : a ffdf data base.\n#' @param ordercols : vector of names of the columns to order the data \n#' @param splits : number of splits to make while ordering. Will avoid memory problems. \n#' @param verbose : if verbose the process. \n#' @export\n\norderffdf <- function(data, ordercols = names(data), splits = 1, verbose = F){\n  require(ffbase)\n  idx <-ffdforder(data[c(ordercols)])\n  if(verbose) print(paste(\"lenght result \", length(idx)))\n  res <- indexffdfsplit(data,idx,splits,verbose)\n  return(res)\n}\n\n\n\n#' Subset a ffdf, with splits and conditions. \n#' \n#' subsetffdf will subset the ffdf using ffwhich over conditions ...\n#' and will make the data using indexffdf \n#' @export\n#' @param data : a ffdf data base.\n#' @param conditioncols : the columns that are used in the condition to subset \n#' @param condition : a condition to subset, like \" diagnose != \"a\" \" \n#' @param splits : number of splits to make while subsetting. Will avoid memory problems. \n#' @param verbose : if verbose the process. \n\nsubsetffdf <- function(data, conditioncols = names(data),condition, splits = 1, verbose = F){\n  require(ffbase)\n  exp <-substitute( (condition) %in% TRUE)\n  idx <- do.call(ffwhich, list(data, exp) ) # here is the trick: do.call !!!\n  #widx <-with(data[c(conditioncols)], ...)\n  #idx <- ffwhich(widx,widx %in% TRUE)  # this makes NA be FALSE ... \n  \n  #exp <-substitute(condition)\n  #idx <-ffwhich(data[c(conditioncols)], exp  )\n  \n  print(paste(\"length result \", length(idx)))\n  res <- indexffdfsplit(data,idx,splits,verbose)\n  return(res)\n}\n\n#'  Simpler ffdfsave  \n#'  \n#'  will save the data in a file named as the data using ffdfsave. \n#'  @export\n\nsaveffdf <- function(...){ require(ffbase); ffdfsave(...,file = all.names(substitute(...))[[1]]  )}\n\n\n#'  Column bind two ffdf data bases. \n#'  \n#'  ffdfs must be same row length \n#'  @export\n\ncbindffdf <- function(x,y){\n  require(ffbase)\n  Ncol1 <- ncol(x); \n  Ncol2 <- ncol(y)\n  for( col in 1:Ncol2){\n    namecol <- names(y)[col]\n    x[[namecol]] <- y[[namecol]] \n    \n  }\n  return(x)\n  \n}\n\n\n#'  Append two ffdf by chunks \n#'  \n#' Will append TWO ffdfs \"x\" and \"y\" by chunks of size \"chunks\"\n#' Will verbose some information on timings.  \n#' @export \n\nappendffdf <- function(x,y,chunks){\n  require(ffbase)\n  chunk <- chunks; \n  y <- y[names(x)] # select only x cols or order them as x \n  Nsplits <- ceiling(nrow(y) / chunk )\n  beg <- Sys.time(); \n  \n  rowend <- 0L\n  \n  for(i in 1:Nsplits){\n    \n    begloop <- Sys.time()\n    rowini <-as.integer( rowend +1)\n    rowend <-as.integer(i * chunk)\n    \n    if(rowend > nrow(y)) rowend <- nrow(y)\n    z <-  y[rowini:rowend, ][,] \n    if(i == 1){ \n      \n      res <- ffdfappend(x,z )\n      \n    } else {\n      \n      res <- ffdfappend(res,z )   \n    }\n    rowini <- rowend +1 \n    timeloop <- Sys.time() - begloop\n    print(paste( \" done split \", i, \"/\", Nsplits, \n                 \", rowend \", rowend, \n                 \" spent : \", round(timeloop) , \n                 \", E. total \", round(timeloop * (Nsplits)), \n                 \", E. remain  \", round( timeloop * (Nsplits -i))  \n    )\n    ) \n  }\n  \n  print(paste(\" Total time :\", round( Sys.time()-beg , digits = 1)))\n  return(res)\n  \n}\n\n#' Merge two data bases (ffdf)\n#' \n#' merge two data bases ffdf\n#' , using a merge in data.table \n#' in the form ::  res <- y[x,nomatch =0 ], so the result will be as y[x, nomatch =0] . \n#' @param splitcolname : it is taking  splitcolname to make splits and not break for same values of that col. \n#' @param keycols :  the common cols to make the merge.\n#' @export\n####################################\n\nfumerge <- function(x,y,splitcolname, keycols ) {\n  require(ffbase); require(data.table)\n  x0 <- x[1,]\n  x0 <- x0[0,]\n  x <-data.table(x[,]); \n  #keycols <- c(\"ident\",\"dateofonderzoek\",\"registry\") \n  setkeyv(x, keycols )\n  z <- y[[splitcolname]]\n  zz <- ffdf( ids = z)\n  xx <-  x[[splitcolname]][]\n  idx <- with(zz, ids %in% xx)\n  idx <- ffwhich(idx,idx)\n  \n  if(length(idx) > 0 ) {\n    \n    #rownames(y) <- NULL  ## to avoid that row.names != NULL  problem... .\n    y <-indexffdf(y,idx)\n    y2 <-data.table(y[,]); \n    setkeyv(y2, keycols )\n    gc()\n    res <- y2[x, nomatch =0] # this makes it equivalent as marge(x,y) and sql( select ... where t1.--- = t2. --- )\n    rm(x,y2,z,idx, xx,zz)\n    res \n  } \n  else {\n    print(\"no matching indexes :: returning empty data.frame\")\n    rm(z,idx, xx)\n    return(x0)\n  }\n  \n}\n\n#' Merge by  two ffdf by chunks \n#'  \n#' merge by is an application of \n#' fumerge, for a big data ffdf. \n#' it will split the comput by chunks \n#' of size chk. \n#' @export\n#' @param x,y : ffdfs to merge. \n#' @param keycols : common columns. \n#' @param splitname : name of the column to make the splits. \n#' @param chk: chunk size (number of rows to take in a single pass)\n####################################\n\nmergeby  <- function(x,y,keycols, splitname,  chk){\n  require(ffbase); require(data.table)\n  chunks <- chk # size of the split.  \n  res <- splitapplycpp(x, x[[splitname]],chunks ,function(x) fumerge(x,y,splitname, keycols)  )\n}\n\n\n#' Index a ffdf by an index vector idx (re-order or subsetting)\n#' \n#' Will index a ffdf by the index idx. (reorder). \n#' avoids memory overflow if one single col is able to go into memory.... \n#' @param x : ffdf \n#' @param idx : index vector (ff vector or ram vector -not prefered-)\n#' @param verbose : verbose the process. \n#' @export\n############################################################\n\nindexffdf <- function(xwe34574, idx, verbose = F ){\n  require(ffbase)\n  gc()\n  colnames <- names(xwe34574)\n  N <- ncol(xwe34574); \n  open.ffdf(xwe34574) \n  \n  for( i in 1:N) {\n    \n    name <- colnames[i]\n    if(verbose) print(paste( \"making row \", name))\n    z14246456457 <- xwe34574[idx, name][[name]]\n    ifelse( i==1 , \n            \n            df <- ffdf( z14246456457 ) , \n            df[[name]] <- z14246456457\n    )\n    #rm(z14246456457)\n    gc()   \n  }\n  names(df) <- colnames\n  df \n  \n  \n}\n\n#' Index a ffdf by an index vector idx (re-order or subsetting)\n#' \n#' Will index a ffdf by the index idx. (reorder). \n#' avoids memory overflow if one single col is able to go into memory.... \n#' avoids memory overflow by splitting the computation in several parts. \n#' @param x : ffdf \n#' @param idx : index vector (ff vector or ram vector -not prefered-)\n#' @param nsplits: number of splits to run. Avoids memory issues.  \n#' @param verbose : verbose the process. \n#' @export \n############################################################\n\nindexffdfsplit <- function(datainput, idx, nsplits = 1, verbose = F ){\n  require(ffbase)\n  gc()\n  colnames <- names(datainput)\n  N <- ncol(datainput); \n  open.ffdf(datainput) \n  \n  for( i in 1:N) {\n    \n    name <- colnames[i]\n    if(verbose) print(paste( \"making row \", name))\n    rowend <- 0\n    Nrows <- nrow(datainput)\n    Nidx <- length(idx)\n    splitrows <- ceiling(Nidx/nsplits)\n    \n    if(nsplits > 1){\n      \n      for( split in 1:nsplits){\n        \n        if(verbose) print(paste( \".... split  \", split, \"/\" , nsplits))\n        rowbeg <- rowend + 1 \n        rowend <- rowend + splitrows\n        \n        if(rowend > Nidx) rowend <- Nidx\n        beg <- as.integer(rowbeg)\n        end <- as.integer(rowend)\n        indxs <- ff(idx[beg:end])\n        \n        y45234316 <- datainput[indxs, name][[name]]\n        \n        ifelse( split==1 , z45234316 <- y45234316 , {z45234316 <- ffappend(z45234316,y45234316)}   )\n        \n      }\n      \n    }else {\n      \n      z45234316 <- datainput[idx, name][[name]] \n    }\n    \n    ifelse( i==1 , \n            \n            df <- ffdf( z45234316 ) , \n            df[[name]] <- z45234316\n    )\n    rm(z45234316)\n    gc() \n    \n  }\n  names(df) <- colnames\n  df \n  \n  \n}\n\n\n#' Apply a function over a ffdf, in splits. \n#' \n#' will apply a function to a ffdf:\n#' avoids memory overflow by splitting the computation in several parts.  \n#' the function fu should return a R data.frame as applied to a R data.frame. \n#' @param datainput : the ffdf to apply the function over. \n#' @param fu : function to apply in the ffdf. It must return a data.frame, as if it is working over a R data.frame. \n#' @param splits : number of splits to process. Avoids memory issues. \n#' @param verbose : verbose the process. \n#' @export\n############################################################\n\napplyffdfsplit <- function(datainput, fu, nsplits = 1, verbose = F )\n{\n  \n  require(ffbase)\n  gc()\n  colnames <- names(datainput)\n  open.ffdf(datainput) \n  \n  rowend <- 0\n  Nrows <- nrow(datainput)\n  Nidx <- Nrows\n  splitrows <- ceiling(Nidx/nsplits)\n  \n  if(nsplits > 1){\n    \n    for( split in 1:nsplits){\n      \n      # if(verbose) print(paste( \".... split  \", split, \"/\" , nsplits))\n      rowbeg <- rowend + 1 \n      rowend <- rowend + splitrows\n      \n      if(rowend > Nidx) rowend <- Nidx\n      beg <- as.integer(rowbeg)\n      end <- as.integer(rowend)\n      indxs <- beg:end\n      if(verbose) print(paste( \".... split  \", split, \"/\" , nsplits, \" \", beg, \":\", end))\n      \n      y45234316 <- datainput[indxs, ]\n      \n      res3123 <- fu(y45234316)\n      \n      rm(y45234316)\n      \n      ifelse( split==1 , z45234316 <- as.ffdf(res3123), {z45234316 <- ffdfappend(z45234316,res3123)}   )\n      \n    }\n    \n  }else {\n    \n    y45234316 <- datainput[,]\n    res3123 <- fu(y45234316)\n    rm(y45234316)\n    z45234316 <- as.ffdf(res3123)\n    \n  }\n  \n  \n  df <- z45234316\n  gc() \n  df \n  \n}\n\n\n\n#' Apply a function over a ffdf, in chunks (number of rows) \n#' \n#' will apply a function to a ffdf\n#' avoids memory overflow by splitting the computation in several parts.  \n#' the function fu should return a R data.frame as applied to a R data.frame. \n#' @param data  : the ffdf to apply the function over. \n#' @param fu : function to apply in the ffdf. It must return a data.frame, as if it is working over a R data.frame. \n#' @param chunksize : number rows to process by split. Avoids memory issues. \n#' @param verbose : verbose the process. \n############################################################\n\napplyffdfchunks <- function(data, fu, chunksize = 1e6, verbose = F )\n{\n  require(ffbase)\n  gc()\n  colnames <- names(data)\n  open.ffdf(data) \n  \n  rowend <- 0\n  Nrows <- nrow(data)\n  Nidx <- Nrows\n  nsplits <- ceiling(Nidx/chunksize)\n  splitrows <- chunksize\n  \n  if(nsplits < 1) nsplits <- 1\n  \n  if(nsplits > 1){\n    \n    for( split in 1:nsplits){\n      \n      #if(verbose) print(paste( \".... split  \", split, \"/\" , nsplits))\n      rowbeg <- rowend + 1 \n      rowend <- rowend + splitrows\n      \n      if(rowend > Nidx) rowend <- Nidx\n      beg <- as.integer(rowbeg)\n      end <- as.integer(rowend)\n      indxs <- beg:end\n      #if(verbose) print(paste( \".... .... rows:   \", beg, \" to \" , end))\n      \n      if(verbose) print(paste( \".... split  \", split, \"/\" , nsplits, \" \", beg, \":\", end))\n      \n      y45234316 <- data[indxs, ]\n      \n      res3123 <- fu(y45234316)\n      \n      rm(y45234316)\n      \n      ifelse( split==1 , z45234316 <- as.ffdf(res3123), {z45234316 <- ffdfappend(z45234316,res3123)}   )\n      \n    }\n    \n  }else {\n    \n    y45234316 <- data[,]\n    res3123 <- fu(y45234316)\n    rm(y45234316)\n    z45234316 <- as.ffdf(res3123)\n    \n  }\n  \n  \n  df <- z45234316\n  gc() \n  df \n  \n}\n\n\n#### functions to get the data from split info :: ################\n\ngetdatasplit <- function(data, chunkindexes, chuknumber){\n  \n  beg <- chunkindexes[chuknumber, \"begdataindex\"]; \n  end <- chunkindexes[chuknumber, \"enddataindex\"];\n  return(data[beg:end, ])\n  \n}\n\ngetdatatablesplit <- function(data, chunkindexes, chuknumber){\n  require(data.table)\n  beg <- chunkindexes[chuknumber, \"begdataindex\"]; \n  end <- chunkindexes[chuknumber, \"enddataindex\"];\n  return(data.table( data[beg:end, ]) )\n  \n}\n\n\n#'  A split-apply-combine over and ORDERED ffdf data.base. \n#'  \n#' split apply over an ORDERED data frame (or ffdf), using the cpp \n#' functions getsplitindexes and getchunksindexesforsplitlist\n\n#'  \\code{fu(x)}  will be something like : \n#'   \\code{ x <- data.table(x) ; setkey(x, \"ident\") ; \n#'  x[ , list( max.diagnose = max(dignose)), by = ident ]\n#'  }  \n#'  for example....\n#'  or any function that gives a data frame operating in each split of the data, \n#'  that are \"respecting\" the split-vector (i does not break data for same values of split-vector)\n#'  @param inputdata : the input ffdf. It MUST BE ORDERED by the SPLIT VECTOR !!. \n#'  @param splitvector : the ff vector to use for the splits. \n#'  @param chksize : the number of rows to take in a single computing pass (RAM)\n#'  @param fu : a function that returns a data.frame over a data.frame (for a single value of the split vector)\n#'  @export\n####################################################################\n\nsplitapplycpp <- function(inputdata, splitvector, chksize , fu){\n  \n  require(ffbase); require(data.table)\n  print(nrow(inputdata))\n  t.begin <- Sys.time()\n  \n  data <- data.frame( ids = as.integer(splitvector[]) ) # create a data frame with one col which is the split factor as integer...\n  \n  splitindexes  <- getsplitindexes(data, \"ids\") # a cpp function to get the indexes for the splits... \n  print(length(splitindexes))\n  \n  #the size for each chunk. Setting to 3e6 rows gets good results. No mem overflow.... lower if there are mem. alloc. problems... \n  chksize <- chksize\n  if(chksize > nrow(inputdata)) chksize = nrow(inputdata); #print(chksize)\n  \n  sp <- getchunksindexesforsplitlist(data, splitindexes, chksize) # cpp function that gives the row numbers for splits in indexes and in data.base.\n  rm(data) \n  data <- inputdata   \n  ##print(sp[1:2,])\n  Nsplits <- nrow(sp); \n  \n  print(paste(\"Number of Splits \" , Nsplits, \" / \", \"Chunk Size\",  chksize )) \n  \n  ########## first process :: using data.table to split ###############\n  #we do not need the splitindexes data ::\n  rm(splitindexes) ; gc()\n  \n  ii <- 0 \n  \n  print(\"Beginning Splits ------ \" )\n  for ( i in 1:Nsplits){ \n    \n    print(paste(\"Split \", i, \"/\", Nsplits))\n    t.beg <- Sys.time()\n    print(gc())\n    splitnumber <- i\n    beg <- sp[splitnumber, \"begdataindex\"]\n    end <- sp[splitnumber, \"enddataindex\"]\n    \n    print(paste(\"---Working on rows  \", beg, \"to \", end))\n    \n    dat <- data[beg:end, ] \n    print(paste(\"------ function\"))\n    ## dat <- getdatatablesplit(data,sp,splitnumber)  \n    ## setkeyv(dat, c(splitname)) \n    \n    res <- fu(dat)   ## fu(x) will be something like : {  x <- data.table(x) ; setkey(x, \"ident\") ; x[ , list( max.diagnose = max(dignose)), by = ident ] } for example.... \n    #print(nrow(res));\n    print(paste(\"------ append  \"))\n    \n    cont <- TRUE \n    ii <- ii+1\n    exp <- (is.data.frame(res) & nrow(res) > 0) %in% FALSE \n    #print(exp)\n    if(exp) { cont <- FALSE ; ii <- ii-1}\n    #print(cont)\n    if( ii == 1 & cont) { result <- as.ffdf(res)}\n    if( ii != 1 & cont) { result <- ffdfappend(result, res)} \n    \n    rm(res) \n    rm(dat) \n    t.e <- Sys.time()\n    print(paste(\"------time elapsed in split \", i , \"of\", Nsplits, \" = \", round(t.e - t.beg, digits = 1)))  \n    print(paste(\"------Estimated total time \",  Nsplits * round(t.e - t.beg, digits = 1),  \"E.Time.Remaining \", (Nsplits-i) * round(t.e - t.beg, digits = 1)  ))\n  }\n  t.end <- Sys.time()\n  print(paste(\"total time elapsed -----  \", round(t.end - t.begin, digits = 1)) )  \n  gc()\n  \n  return(result)  \n  \n}\n\n\n#'  Lag a vector by 1 position, with value NA . \n#'  \n#' if the original vector is \\code{ x = c(0,1,2)} the result \n#' will be \\code{ lagpad(x) --> c(NA,0,1)}.\n\n#'  @export\n####################################################################\n\nlagpad <- function(x) {\n  \n  N <- length(x)\n  if(is.factor(x)){\n    lev <- levels(x)\n    xlag <- factor(c(NA,as.character(x)), levels = lev)[1:N]\n    #print(xlag)\n    \n  } else {\n    xlag <- c(NA, x)[1:N]\n    \n  }\n  xlag\n}\n\n#'  Integer to date with no need of specifying the origin. \n#'  \n#' Assumes the origin to be 1970-01-01. \n#' \\code{asDate(x)} is the same as \\code{as.Date(x,origin=\"1970-01-01\")} \n#'  @export\n\nasDate <- function(x) {\n  \n  return ( as.Date(x, origin=\"1970-01-01\"))\n}\n\n\n#' Numeric to percent with percent symbols for labelling \n#' \n#' numeric to percents with percent symbols for labelling , with \"dec\" = decimals to display. \n#' @examples\n#' pp <- c(23.121 , 1.34, 0.345); \n#' fpp <- txt.perc(pp,2); fpp\n#' fpp <- txt.perc(pp,1); fpps\n#' @export \ntxt.perc <- function(x, dec){ paste( format ( x, digits = 1, nsmall = dec), \"%\", sep = \"\") }\n\n\n#' Fill a vector with characters to get a fixed character length for all the items. \n#'  \n#' Will add 0 at the beginning for integer and numeric vectors \n#' and the \"fill\" character at the END for other types. \n#' @param x : a vector \n#' @param fill : a character to \"fill\" the vector. \n#' @export \n#' @return a character vector of fixed width (equal to the maximum input width)\nfill.vec <- function(x, fill = \"*\") {\n  \n  #if(class(x) ==\"Date\" ) return(x)\n  \n  \n  if(is.integer(x) | is.numeric(x)){\n    \n    fill <- 0\n    y1 <- as.character(x)\n    y2 <- sub('^ +', '', sub(' +$', '', y1))  ## delete spaces only outside the element\n    #print(y)\n    rm(y1)\n    z <- nchar(y2)\n    max.char <- max(z,na.rm = TRUE)\n    min.char <- min(z,na.rm = TRUE)\n    if(max.char == min.char) return(y2)  ## if char is constant, then return original... \n    rm(z)\n    char.print <- paste(\"% \",max.char,\"s\",sep=\"\")\n    y3 <- sprintf(char.print,y2)\n    rm(y2)\n    #print(y)\n    \n    y <- gsub(\" \", fill, y3)\n    rm(y3)\n    #print(y)\n    #rm(y)\n    return(y)\n  }\n  \n  \n  y1 <- as.character(x)\n  y2 <- sub('^ +', '', sub(' +$', '', y1))  ## delete spaces only outside the element\n  z <- nchar(y2)\n  max.char <- max(z,na.rm = TRUE)\n  min.char <- min(z,na.rm = TRUE)\n  if(max.char == min.char) return(y2)  ## if char is constant, then return original... \n  rm(z, y1)\n  \n  char.print <- paste(\"% -\",max.char,\"s\",sep=\"\")\n  \n  dull.replace <-\"ý\"\n  y3 <- gsub(\" \", dull.replace, y2) # change the white spaces to a \"dull\" character (a very strange one,,,) ...\n  rm(y2)\n  y4 <- sprintf(char.print,y3)      # write spaces padding . \n  rm(y3)\n  y5 <- gsub(' ', fill, y4)       # now change the white spaces for the fill character.\n  rm(y4)\n  y <- gsub(dull.replace, \" \", y5)  # recover the white spaces.\n  rm(y5)\n  #rm(y)\n  gc()\n  return(y)\n}\n\n#' Fill a vector with characters to get a fixed width for all the items. \n#'  \n#' Will ALWAYS  add the  fill\" character at the END for other types. \n#' @param x : a vector \n#' @param fill : a character to \"fill\" the vector. \n#' @export \n#' @return a character vector of fixed width (equal to the maximum input width)\nfill.vec.all.same <- function(x, fill = \"*\") {\n  \n  y1 <- as.character(x)\n  y2 <- sub('^ +', '', sub(' +$', '', y1))  ## delete spaces only outside the element\n  z <- nchar(y2)\n  max.char <- max(z,na.rm = TRUE)\n  min.char <- min(z,na.rm = TRUE)\n  if(max.char == min.char) return(y2)  ## if char is constant, then return original... \n  rm(z, y1)\n  \n  char.print <- paste(\"% -\",max.char,\"s\",sep=\"\")  # write padded spaces after to make all same length. \n  \n  dull.replace <-\"ý\"\n  y3 <- gsub(\" \", dull.replace, y2) # change the white spaces to a \"dull\" character (a very strange one,,,) ...\n  rm(y2)\n  y4 <- sprintf(char.print,y3)      # write spaces padding . \n  rm(y3)\n  y5 <- gsub(' ', fill, y4)       # now change the white spaces for the fill character.\n  rm(y4)\n  y <- gsub(dull.replace, \" \", y5)  # recover the white spaces.\n  rm(y5)\n  #rm(y)\n  gc()\n  return(y)\n}\n\n\n\n#' Fill a data.frame with characters to get a fixed character length for all the items. \n#'  \n#' Will add 0 at the beginning for integer and numeric vectors \n#' and the \"fill\" character at the END for other types. \n#' @param x : a data.frame \n#' @param fill : a character to \"fill\" the vectors. \n#' @param make.factors : if making the resulting columns as factors.\n#' @export \n#' @return a character vector of fixed width (equal to the maximum input width)\nfill.data.frame <- function(x, fill.char = \"*\", make.factors = F){   \n  \n  #y <- x \n  fill <- fill.char \n  \n  for (i in 1:ncol(x)){\n    \n    x[,i] <- fill.vec( x[,i], fill)\n    #if(class(x[[i]] == \"factor\"))  y[,i] <- as.factor(y[,i])\n    if(make.factors) x[,i] <- as.factor(x[,i]) \n    gc()\n    \n  }\n  \n  return(x)\n}\n\n\n#' Fill a data.frame with characters to get a fixed width for all the items. \n#'  \n#' Will ALWAYS  add the  fill\" character at the END for other types. \n#' @param x : a data.frame \n#' @param fill : a character to \"fill\" the vectors. \n#' @param make.factors : if making the resulting columns as factors.\n#' @export \n#' @return a character vector of fixed width (equal to the maximum input width)\nfill.data.frame.all.same <- function(x, fill.char = \"*\", make.factors = F){   \n  \n  #y <- x \n  fill <- fill.char \n  \n  for (i in 1:ncol(x)){\n    \n    x[,i] <- fill.vec.all.same( x[,i], fill)\n    #if(class(x[[i]] == \"factor\"))  y[,i] <- as.factor(y[,i])\n    if(make.factors) x[,i] <- as.factor(x[,i]) \n    gc()\n    \n  }\n  \n  return(x)\n}\n\n\ninfo.time.done <- function(id, uid, begin){\n  \n  ## id is the variable in the loop that grows while computing. \n  ## uid is the unique values of that id, the total number of steps. \n  ## begin is the beginning time as in begin <- Sys.time()\n  \n  #output the percent done ::::\n  #calculate the time left :: \n  \n  mm <- floor(id/uid*10) != floor((id+1)/uid*10)\n  \n  if(mm ) {\n    \n    perc <- round((id / uid * 100 )); \n    t.tmp <- paste(perc, \"%\", sep = \"\")\n    predicted  <- (Sys.time()-begin) * (100/perc);\n    nowleft <- predicted * (1-perc/100); \n    t2.tmp <- paste( \"time left\" , format(nowleft)  )\n    t3.tmp <- paste( \"total time predicted\" , format(predicted)  )\n    t4.tmp <- paste(t.tmp, t2.tmp, sep = \" // \")\n    print( paste( t4.tmp, t3.tmp, sep = \" // \" ) )\n    \n    \n  }\n}\n\n\n\ngrouprunningcumsum <- function (x, max) \n{\n  require(ffbase)\n  l <- as.integer(length(x))\n  if (l == 0) {\n    return(x)\n  }\n  x <- as.integer(x)\n  max <- as.integer(max)\n  result <- .C(\"grouprunningcumsum\", x = x, l = l, max = max, \n               PACKAGE = \"ffbase\")\n  result$x\n}\n\nffdfgetcolumnwise <-function (x, index = NULL) \n{\n  require(ffbase)\n  listtodf <- function(list) {\n    rows <- unique(unlist(lapply(list, NROW)))\n    structure(list, class = \"data.frame\", row.names = seqlen(rows))\n  }\n  res <- list()\n  if (is.null(index)) {\n    for (measure in names(x)) {\n      open(x[[measure]])\n      res[[measure]] <- x[[measure]][]\n      close(x[[measure]])\n    }\n  }\n  else if (is.ff(index)) {\n    if (vmode(index) %in% c(\"boolean\", \"logical\")) {\n      index <- ffwhich(index, index == TRUE)\n    }\n    os <- ffindexordersize(length = NROW(x), vmode = \"integer\")\n    o <- ffindexorder(index, os$b)\n    for (measure in names(x)) {\n      open(x[[measure]])\n      res[[measure]] <- ffindexget(x = x[[measure]], index = index, \n                                   indexorder = o)[]\n      close(x[[measure]])\n    }\n  }\n  else {\n    for (measure in names(x)) {\n      open(x[[measure]])\n      res[[measure]] <- x[[measure]][index]\n      close(x[[measure]])\n    }\n  }\n  listtodf(res)\n}\n\n\n\n#' A simple modification of ffdfdply from ffbase package. \n#' \n#' it will make the computation more clear by outputting time-info  \n#' @export\n\nffdfsplit <-  function (x, split, FUN, BATCHBYTES = getOption(\"ffbatchbytes\"),   RECORDBYTES = sum(.rambytes[vmode(x)]), trace = TRUE, ...) \n{\n  begin <- Sys.time() #mio. \n  require(ffbase)\n  splitvmode <- vmode(split)\n  if (splitvmode != \"integer\") {\n    stop(\"split needs to be an ff factor or an integer\")\n  }\n  splitisfactor <- is.factor.ff(split)\n  MAXSIZE = BATCHBYTES/RECORDBYTES\n  message(\"making the table.ff .... \")\n  splitbytable <- table.ff(split, useNA = \"no\")\n  print(gc())\n  \n  #m: ordering the split by table: i.e. first the one which has the bigger split- \n  #m: i do not want this one to happen, so i re-define :: \n  #m: in this way, i get the same order as the data :: \n  \n  splitbytableo <- splitbytable[order(splitbytable, decreasing = TRUE)]\n  if (max(splitbytableo) > MAXSIZE) {\n    warning(\"single split does not fit into BATCHBYTES\")\n  }\n  rm(splitbytableo)\n  \n  #m: so now the splits are not ordered by number of same items, by as the factors or dates, of whatever.... \n  \n  tmpsplit <- grouprunningcumsum(x = as.integer(splitbytable), \n                                  max = MAXSIZE)\n  nrsplits <- max(tmpsplit) #the number of splits we will do. \n  \n  allresults <- NULL\n  for (idx in 1:nrsplits) {\n    \n    beg <- Sys.time() #mio\n    \n    tmp <- names(splitbytable)[tmpsplit == idx] # tmp is the ids of the ones in this split.  \n    \n    if (!splitisfactor) {\n      if (!is.null(ramclass(split)) && ramclass(split) == \n            \"Date\") {\n        tmp <- as.Date(tmp)\n      }\n      else {\n        tmp <- as.integer(tmp)\n      }\n    }\n    if (trace) {\n      message(sprintf(\"%s, working on split %s/%s , uniques : %s\", \n                      #Sys.time(), idx, nrsplits, paste(tmp, collapse = \", \")))\n                      Sys.time(), idx, nrsplits, length(tmp)  ) ) \n    }\n    if (splitisfactor) {\n      fltr <- split %in% ff(factor(tmp, levels = names(splitbytable)))\n    }\n    else {\n      if (!is.null(ramclass(split)) && ramclass(split) == \n            \"Date\") {\n        fltr <- split %in% ff(tmp, vmode = \"integer\", \n                              ramclass = \"Date\")\n      }\n      else {\n        fltr <- split %in% ff(tmp, vmode = \"integer\")\n      }\n    }\n    \n    #message( sprintf(\"---ffdfgetcolumnwise \") )  # mio\n    inram <- ffdfgetcolumnwise(x, fltr)\n    #message( sprintf(\"---end  ffdfgetcolumnwise\") )  # mio\n    if (trace) message( sprintf(\"---beginning FUN call --- length data : %s\", nrow(inram) ))  # mio \n    begf <- Sys.time()  # mio\n    \n    result <- FUN(inram, ...)\n    gc() #mio ... \n    if (trace) message(paste(\"---end FUN call: time spent in FUN \" ,round( Sys.time() - begf )) ) #mio. \n    \n    if (!inherits(result, \"data.frame\")) {\n      stop(\"FUN needs to return a data frame\")\n    }\n    rownames(result) <- NULL\n    if (!is.null(allresults) & nrow(result) > 0) {\n      rownames(result) <- (nrow(allresults) + 1):(nrow(allresults) + \n                                                    nrow(result))\n    }\n    if (trace) message(\"--beginning append\")\n    if (nrow(result) > 0) {\n      allresults <- ffdfappend(x = allresults, dat = result, \n                               recode = FALSE)\n    }\n    \n    dif.time <- Sys.time()- beg #mio \n    if (trace) message(\n      paste(\n        \"--end append // time spent in split: \", round(dif.time), \n        \" // estimated time left ::\", round( (nrsplits - idx) * dif.time) ) ,\n      \" // estimated total time ::\", round( nrsplits* dif.time) \n    ) #mio \n    message(\" ------------------------------------------------\") #mio\n    \n  }\n  print(paste(\"total time spent ::\", Sys.time() - begin )) #mio \n  allresults\n}\n\n\n\n",
    "created" : 1379070173529.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1038175491",
    "id" : "DE83EB71",
    "lastKnownWriteTime" : 1379070637,
    "path" : "P:/Projects/Large_data_and_R/PACKAGE/LargeData_thomas/R/functions.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}