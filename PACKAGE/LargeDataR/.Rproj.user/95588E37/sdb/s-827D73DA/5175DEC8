{
    "contents" : "#include <Rcpp.h>\n//#include <RcppArmadillo.h>\n#include <string>    // for std::string and std::getline\n\nusing namespace Rcpp;\nusing namespace std;\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\ntemplate <int RTYPE>\nVector<RTYPE> roll_vector_na(const Vector<RTYPE>& x) {\n  \n    int n = x.size() ;\n\n    Vector<RTYPE> out = clone(x) ;\n    \n    for( int i=1;   i<n; i++){\n        \n        //printf(\"elem %d\", i); \n        \n        if( Vector<RTYPE>::is_na( x[i] ) ) \n          out[i] = out[i-1];\n        else \n          out[i] = x[i];\n    }\n    \n    return out ;\n}\n\n\n// [[Rcpp::export(na_roll_cpp)]]\nSEXP na_omit(SEXP x) {\n    switch(TYPEOF(x)) {\n        case INTSXP:\n            return roll_vector_na<INTSXP>(x);\n        case REALSXP:                   \n            return roll_vector_na<REALSXP>(x);\n        case LGLSXP:\n            return roll_vector_na<LGLSXP>(x);\n        default:\n            stop(\"unsupported data type\");\n    }\n}\n\n// [[Rcpp::export]]\nSEXP roll_vector_nas( SEXP x ){\n     RCPP_RETURN_VECTOR( roll_vector_na, x ) ;   \n}\n\n\n*/\n\nIntegerVector  roll_vector_int(IntegerVector x) {\nIntegerVector  v(x) ;\nint Nidx = v.size();\nIntegerVector result = clone(v); \nfor( int i = 1; i < Nidx; i++){\nif(IntegerVector::is_na( result[i] )) result[i] = result[i-1] ;  \n}\nreturn result;\n}\n\n\nNumericVector  roll_vector_num(NumericVector x) {\nNumericVector  v(x) ;\nint Nidx = v.size();\nNumericVector result = clone(v); \nfor( int i = 1; i < Nidx; i++){\n  if(NumericVector::is_na( result[i] )) result[i] = result[i-1] ;  \n}\nreturn result;\n}\n\nCharacterVector  roll_vector_char(CharacterVector x) {\nCharacterVector  v(x) ;\nint Nidx = v.size();\nCharacterVector result = clone(v); \nfor( int i = 1; i < Nidx; i++){\n  if(CharacterVector::is_na( result[i] )) result[i] = result[i-1] ;  \n}\nreturn result;\n}\n\nLogicalVector  roll_vector_log(LogicalVector x) {\nLogicalVector  v(x) ;\nint Nidx = v.size();\nLogicalVector result = clone(v); \nfor( int i = 1; i < Nidx; i++){\n  if(LogicalVector::is_na( result[i] )) result[i] = result[i-1] ;  \n}\nreturn result;\n}\n\n\n\n// [[Rcpp::export(roll_vector_nas)]]\nSEXP roll_vector_nas(SEXP x) {\n    switch(TYPEOF(x)) {\n        case INTSXP:\n            return roll_vector_int(x);\n        case REALSXP:                   \n            return roll_vector_num(x);\n        case LGLSXP:\n            return roll_vector_log(x);\n        case  STRSXP:\n            return roll_vector_char(x);\n        default:\n            return x;\n    }\n}\n\n\n/*\n// [[Rcpp::export]]\nSEXP roll_vector_nas( SEXP x ){\n     RCPP_RETURN_VECTOR( roll_vector_na, x ) ;   \n}\n\n*/\n\n\n\n\n// [[Rcpp::export]]\nList subsetCpp( DataFrame data, IntegerVector indxs){\n  \n  // this function will subset a DataFrame, by the vector of indexes \n  // indxs. \n  // It returns a List, because returning a DataFrame takes aprox 100 x more. \n  //cout << \"begin subset\" << endl; \n  DataFrame df(data); \n  int ncol = Rf_length(df);\n  CharacterVector colNames(ncol); \n  SEXP names = Rf_getAttrib(df, R_NamesSymbol);\n  SEXP colData = VECTOR_ELT(df,0); // First column of data.\n  //int nrow = Rf_length(colData);\n  // IntegerVector indexes = IntegerVector::create(1,5,10); \n  IntegerVector indexes = clone(indxs);  \n  indexes = indexes -1 ; \n  int Nidx = indexes.size(); \n  \n  List result(ncol); \n  \n  for (int i=0; i < ncol; i++) {\n    \n    colNames[i] = std::string(CHAR(STRING_ELT(names,i)));\n    \n    SEXP colData = df(i);\n    \n    bool isDateClass = false;\n    SEXP classname = Rf_getAttrib(colData, R_ClassSymbol);\n\n    if (classname != R_NilValue)\n      isDateClass = (strcmp(CHAR(STRING_ELT(classname,0)),\"Date\") == 0);   \n      \n    if (Rf_isReal(colData)) { // REAL \n      \n      NumericVector subsetData(Nidx);\n      NumericVector v = as<NumericVector>(colData); \n      \n      if (isDateClass) subsetData.attr(\"class\") = \"Date\";\n      \n        for (int j=0; j < Nidx; j++) {\n                  int idx = indexes[j]; \n                  subsetData[j] = v[idx];\n        }\n        result[i] = subsetData;\n        //cout << \"Real Col \" << i << endl; \n    }   \n    \n    else if (Rf_isInteger(colData)) {  // INTEGER \n      \n         IntegerVector subsetData(Nidx);\n         IntegerVector v = as<IntegerVector>(colData);\n         \n         if (isDateClass) subsetData.attr(\"class\") = \"Date\";\n         \n         for (int j=0; j < Nidx; j++) {\n                  int idx = indexes[j]; \n                  subsetData[j] = v[idx];\n         }\n         result[i] = subsetData;\n         //cout << \"Int Col \" << i << endl;\n    }  \n    \n     else if (Rf_isString(colData)) { // Non-factor string column\n        CharacterVector subsetData(Nidx);\n         CharacterVector v = as<CharacterVector>(colData);\n           for (int j=0; j < Nidx; j++) {\n                  int idx = indexes[j]; \n                  subsetData[j] = v[idx];\n         }\n         result[i] = subsetData;\n     } \n    \n    \n     else if (Rf_isFactor(colData)) { // Factor column.\n     \n          IntegerVector subsetData(Nidx);\n          IntegerVector v = as<IntegerVector>(colData);\n          \n          SEXP names = Rf_getAttrib(colData, R_LevelsSymbol);\n          int numLevels = Rf_length(names);\n          //std::string *levelNames = new std::string[numLevels];\n          CharacterVector levelNames = Rf_getAttrib(colData, R_LevelsSymbol); \n          //for (int k=0; k < numLevels; k++)\n          //levelNames[k] = std::string(CHAR(STRING_ELT(names,k)));\n          \n          //for (int k=0; k < numLevels; k++) cout << levelNames[k] ; \n          //cout << endl; \n          //cout << \" factor col\" << endl; \n          subsetData.attr(\"levels\") =  levelNames;  \n          subsetData.attr(\"class\") = \"factor\";\n          \n           for (int j=0; j < Nidx; j++) {\n                  int idx = indexes[j]; \n                  subsetData[j] = v[idx];\n          }\n          result[i] = subsetData;\n          //delete [] levelNames;\n     }\n      \n      else if (Rf_isLogical(colData)) {  // LOGICAL \n          LogicalVector subsetData(Nidx);\n          LogicalVector v = as<LogicalVector>(colData);\n          for (int j=0; j < Nidx; j++) {\n                  int idx = indexes[j]; \n                  subsetData[j] = v[idx];\n          }\n          result[i] = subsetData;\n     }\n     \n     else {   // WHEN COL IS NOT TREATED \n        \n       \n       CharacterVector vv(Nidx, \"ERROR\"); \n       result[i] = vv; \n       \n     }\n    \n  }\n\n  result.attr(\"names\") = colNames;\n  //result.attr(\"class\") = \"list\"; \n  //Rcpp::DataFrame res(result);  // this makes it 100x slower than List .... \n  //cout << \"end subset\" << endl;\n  //return(res); \n  return(result); \n  \n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// [[Rcpp::export]]\nList getSubsetSplit(DataFrame Dsexp, List split_idx, int beg_index, int end_index, Function fun )\n{\n\n// get_split will apply function fun to each one of the split-indexes in the split_idx list. \n// beg_index and end_index can be obtained from get_chunks_indexes_for_split_list, \n// and will make possible to work with chunks of data. \n// the function to apply MUST be working with a list of lists...\n// so we should have like fu_apply <- function(x){ lapply(x, fu )} \n// fu <- function(x) {  c(min.date = min( x[\"date\"] )  }  for example.... \n\nDataFrame data = DataFrame(Dsexp);\nFunction fu  = Function(fun);\nList split_id = clone(split_idx);\n\nint Napply = end_index - beg_index + 1 ; \nint beg = (beg_index -1) ; \nint end = (end_index) ; \nList sol(Napply); \nIntegerVector first_split = split_id[beg]; \nint first_index = first_split[0]; \n\nint lag_indexes = 0; \nif(first_index != 1) { lag_indexes = first_index  -1; }; \n\n//cout << \"lag index for data : \" << lag_indexes << endl; \n\nint sol_index = 0; \n\nfor (int i=beg ; i < end ; i++){\n   IntegerVector idx = split_id(i) ;\n   IntegerVector idx_ = idx - lag_indexes;       // take into account that the data can be subsetted , so first index of all is set to 1. \n   //cout << \"f index \" << idx_[0] << endl; \n   List sub_data = subsetCpp(data, idx_); \n   cout << \"split \" << i+1 << \"/\" << end << endl; \n   //indexes.push_back( idx );  \n   sol[sol_index] = fu(sub_data); \n   sol_index += 1; \n}\n\n//sol = Lapply(indexes, fu); \n\n//List examp = sol[0]; \n//CharacterVector names = Rf_getAttrib(examp, R_NamesSymbol);\n//sol.attr(\"names\") = names; \n//DataFrame res(sol);\n//return(res);\nreturn(sol); \n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// [[Rcpp::export]]\nRcpp::List getSplitIndexes(Rcpp::DataFrame Dsexp, SEXP split_row_name)\n{\n\n\n// it will get the split indexes by same values of split_row_name. \n// the result of this feeded into get_split will make a split-apply-combine. \n\nRcpp::DataFrame data = Rcpp::DataFrame(Dsexp);\n//Rcpp::Function fu = Rcpp::Function(fun);\nstring split_name = Rcpp::as<string>(split_row_name);\nRcpp::IntegerVector ids = data[split_name];\n\n\nint id_i =  ids[0];\nint N = ids.size();\nRcpp::IntegerVector indexes ; \n\nstd::set<int> s( ids.begin(), ids.end() );\nint uniqueN = s.size(); \n\n// a way to call R functions:: \n//Environment base(\"package:base\");\n//Function rm = base[\"rm\"];\n//rm(\"s\"\",\"ids); \n\n// another one :: \n//Rcpp::Function length(\"length\");\n//int ll =  Rcpp::as<int>(length(ids));\n//cout << ll << endl; \n\nprintf(\"data size :: %d , uniques : %d \\n\", N, uniqueN);\n\nRcpp::List sol(uniqueN);\nint nrows = 0; \nint id_int = 0;\n\nfor (unsigned int i=0; i < (unsigned int) N; i++){\n  nrows += 1;\n  \n  if(nrows%1000000 == 0) printf(\" rows done :: %d\\n\", nrows); \n  \n  int new_id = ids[i] ; // is there a new value for the split ??  \n  \n    if( new_id == id_i) { \n\n      indexes.push_back(i+1);\n      \n      if(i ==  N-1 ){\n        sol[id_int] =  indexes; \n        //sol[id_i-1] = indexes; \n      };\n    };\n    // change in id  value..   \n    \n    if( new_id != id_i){\n       \n      //printf(\" id :  %d\\n\", new_id);\n      int ll = indexes.size(); \n      //printf(\" indexes size  :  %d\\n\", ll);\n      sol[id_int] = indexes;\n      id_i = new_id;\n      id_int +=1;\n      Rcpp::IntegerVector indxx ;\n      indexes = indxx; \n      //indexes.clear(); \n      indexes.push_back(i+1);\n      if(i ==  N-1) sol[id_int] = indexes;\n      \n    };\n  \n}\n    return(sol);\n\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// [[Rcpp::export]]\nList Lapply(List data, Function fun){\n  List input(data);\n  Function f(fun);\n  List output(input.size());\n  transform( input.begin(), input.end(), output.begin(),f);\n  output.names() = input.names();\n  return output;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// [[Rcpp::export]]\nDataFrame getChunksIndexesForSplitList(DataFrame data_, List split_indx, int chk_size){\n  \n  // will make a DataFrame with info for indexes on split_indx list and DataFrame indexes\n  // to work on different chunks\n  // this is the output :: \n  //#     chunk_number beg_split_index end_split_index beg_data_index end_data_index\n  //# 1             1               1            6586              1         100018\n  //# 2             2            6587           13372         100019         200001\n  List split_indexes(split_indx); \n  DataFrame data = data_; \n  int chuk_size  = chk_size; \n  int chuk_row =  chuk_size; \n  int Nsplits = ceil( data.nrows()/ ((double)chuk_size ) ) ; \n  // if(Nsplits == 0) Nsplits = 1; \n  //\n  \n  printf(\"Nsplits %d , Nrows %d , chk_size %d \\n\", Nsplits,data.nrows(), chuk_size ) ; \n  int Nindexes = split_indexes.size(); \n  IntegerVector chuk_split_index(Nsplits); \n  IntegerVector chuk_begin_data(Nsplits); \n  IntegerVector chuk_end_data(Nsplits); \n  //printf(\"Nsplits %d \\n\", Nsplits) ;\n  int split_number =  0 ; \n  //int last_i =  0 ; \n  \n  for(int i = 0 ;  i <  Nindexes ; i++){\n  //printf(\"loop %d \\n\", i) ;  \n    IntegerVector split = split_indexes(i) ; \n    int maxi =  max(split); \n    \n    if(maxi >= chuk_row ){ \n      \n      chuk_split_index[split_number] = i; \n      printf(\"split n %d chuk_row %d chuk_split_index %d \\n\" ,split_number, chuk_row, i); \n      chuk_row =  chuk_row + chuk_size; \n      split_number = split_number + 1; \n      //last_i = i ; \n    }\n    \n  }\n  //printf(\"done splits, split_number %d \\n\", split_number) ;\n  // if(split_number == Nsplits-1 & Nsplits != 1) {\n  if(split_number == Nsplits-1 ) {  \n\n    chuk_split_index[split_number] =  Nindexes -1;  //  case when we got until the end, but there were some remaining indexes ... \n    \n  }   \n  \n  // make the vector of the begin indexes :: \n  IntegerVector chunk_number = seq_len(Nsplits);  \n  IntegerVector chuk_beg(Nsplits);\n  chuk_beg[0] = 0 ; \n  \n  for(int i = 1;  i <  Nsplits ; i++){\n    \n    chuk_beg[i] = chuk_split_index[i-1] + 1; \n  }\n\n  // now make the vector of the beg and end data indexes ::: \n  \n  for(int i = 0;  i <  Nsplits; i++){\n    int chu = chuk_beg[i]; \n    int idx = chuk_split_index[i]; \n    //if(idx == )\n    IntegerVector spl_b  =   split_indexes(chu); \n    IntegerVector spl_e  =   split_indexes(idx);\n    chuk_begin_data[i] = min(spl_b); \n    chuk_end_data[i] = max(spl_e);\n  }\n  \n  \n  DataFrame DF = Rcpp::DataFrame::create( \n    Named(\"chunk_number\")=chunk_number, \n    Named(\"beg_split_index\")=chuk_beg +1 , \n    Named(\"end_split_index\")=chuk_split_index +1 ,\n    Named(\"beg_data_index\")=chuk_begin_data,\n    Named(\"end_data_index\")=chuk_end_data \n  );\n  //return(  data.frame(chunk_number =chunk_number, beg_split_index = chuk_beg, end_split_index = chuk_split_index, beg_data_index = chuk_begin_data, end_data_index = chuk_end_data  ))\n  return(DF); \n  \n}\n\n\n          \n",
    "created" : 1379330839237.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2089059156",
    "id" : "5175DEC8",
    "lastKnownWriteTime" : 1379328841,
    "path" : "~/Projects/RcppPackage/New/LargeDataCppFunctions/src/subset_df.cpp",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "cpp"
}